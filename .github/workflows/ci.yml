name: CI

on:
  push:
    branches: [ main ]
  pull_request:

permissions:
  contents: read

jobs:
  build-test:
    runs-on: ubuntu-latest
    permissions:
      contents: read
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        
      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        
      - name: Cargo test
        run: cargo test --verbose
        
      - name: Build tool binary
        run: python3 orchestrator.py --mode build --verbose
        
      - name: Integration test (ingest + validate)
        run: python3 orchestrator.py --mode test --verbose

  multi-arch:
    needs: build-test
    runs-on: ubuntu-latest
    timeout-minutes: 45
    permissions:
      contents: read
    strategy:
      matrix:
        platform: [linux/amd64, linux/arm64]
      fail-fast: false
      max-parallel: 2
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Rust
        uses: dtolnay/rust-toolchain@stable
        
      - uses: docker/setup-qemu-action@v3
        with:
          platforms: arm64
      
      - uses: docker/setup-buildx-action@v3
        with:
          driver-opts: |
            image=moby/buildkit:latest
            network=host
      
      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          key: ${{ matrix.platform }}
      
      - name: Configure build parallelism
        run: |
          # Increase parallelism for faster builds
          echo "CARGO_BUILD_JOBS=$(nproc)" >> $GITHUB_ENV
          echo "MAKEFLAGS=-j$(nproc)" >> $GITHUB_ENV
          # Use all available cores
          echo "Available cores: $(nproc)"
      
      - name: Build with timeout monitoring for ${{ matrix.platform }}
        timeout-minutes: 30
        run: |
          set -e
          
          # Create a monitoring script for hang detection
          cat > /tmp/monitor_build.sh << 'EOF'
          #!/bin/bash
          PID=$1
          TIMEOUT=$2
          CHECK_INTERVAL=60
          LAST_OUTPUT_TIME=$(date +%s)
          LOG_FILE="/tmp/build_monitor.log"
          
          echo "Monitoring PID $PID with ${TIMEOUT}s timeout" > "$LOG_FILE"
          
          while kill -0 $PID 2>/dev/null; do
            sleep $CHECK_INTERVAL
            CURRENT_TIME=$(date +%s)
            ELAPSED=$((CURRENT_TIME - LAST_OUTPUT_TIME))
            
            # Check if process is actually doing work
            if ps -p $PID -o %cpu | tail -1 | awk '{if ($1 < 1) exit 1}'; then
              # Process is active, reset timer
              LAST_OUTPUT_TIME=$CURRENT_TIME
              echo "$(date): Process active (CPU usage detected)" >> "$LOG_FILE"
            else
              echo "$(date): Process idle for ${ELAPSED}s" >> "$LOG_FILE"
              if [ $ELAPSED -gt $TIMEOUT ]; then
                echo "$(date): TIMEOUT - Process hung for ${ELAPSED}s, terminating" >> "$LOG_FILE"
                kill -9 $PID
                exit 124
              fi
            fi
          done
          EOF
          
          chmod +x /tmp/monitor_build.sh
          
          # Platform-specific build strategy
          if [ "${{ matrix.platform }}" = "linux/arm64" ]; then
            echo "üî® Building for arm64 (QEMU emulated)"
            echo "Strategy: Build-only validation (full tests already run on amd64)"
            
            # Start build with monitoring
            (
              timeout 1800 python3 orchestrator.py \
                --mode build \
                --platform ${{ matrix.platform }} \
                --verbose 2>&1 | tee /tmp/arm64_build.log
            ) &
            BUILD_PID=$!
            
            # Monitor for hangs (300s = 5min idle timeout)
            /tmp/monitor_build.sh $BUILD_PID 300 &
            MONITOR_PID=$!
            
            # Wait for build to complete
            wait $BUILD_PID
            BUILD_EXIT=$?
            kill $MONITOR_PID 2>/dev/null || true
            
            if [ $BUILD_EXIT -eq 124 ]; then
              echo "‚ùå Build timed out or hung"
              echo "Last 50 lines of output:"
              tail -50 /tmp/arm64_build.log
              exit 1
            elif [ $BUILD_EXIT -ne 0 ]; then
              echo "‚ùå Build failed with exit code $BUILD_EXIT"
              exit $BUILD_EXIT
            fi
            
            echo "‚úÖ ARM64 build successful"
            
          else
            echo "üî® Building and testing for amd64 (native)"
            python3 orchestrator.py \
              --mode full \
              --platform ${{ matrix.platform }} \
              --verbose
          fi
      
      - name: Upload build logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: build-logs-${{ matrix.platform }}
          path: |
            /tmp/*.log
            /tmp/build_monitor.log
          retention-days: 7
      
      - name: Report build metrics
        if: always()
        run: |
          echo "## Build Metrics for ${{ matrix.platform }}"
          echo "Duration: $SECONDS seconds"
          echo "Available memory:"
          free -h
          echo "CPU info:"
          lscpu | grep -E "^CPU\(s\)|Model name|Thread|Core"

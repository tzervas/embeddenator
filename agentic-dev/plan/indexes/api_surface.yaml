# Embeddenator API Surface Reference
# Purpose: Quick lookup for agent code generation

modules:
  vsa:
    path: src/vsa.rs
    exports:
      - name: DIM
        type: const usize
        value: 10000

      - name: ReversibleVSAConfig
        type: struct
        fields:
          - {name: block_size, type: usize, desc: "Block size for chunked reversible encoding"}
          - {name: max_path_depth, type: usize, desc: "Maximum depth used for path-based shifts"}
          - {name: base_shift, type: usize, desc: "Base cyclic shift used in reversible encoding"}
          - {name: target_sparsity, type: usize, desc: "Target sparsity used for thinning"}
        methods:
          - sig: "fn default() -> Self"
            desc: Default encoding/decoding parameters
          - sig: "fn small_blocks() -> Self"
            desc: Preset optimized for small blocks
          - sig: "fn large_blocks() -> Self"
            desc: Preset optimized for large blocks
        
      - name: SparseVec
        type: struct
        fields:
          - {name: pos, type: "Vec<usize>", desc: "Indices with +1 value"}
          - {name: neg, type: "Vec<usize>", desc: "Indices with -1 value"}
        methods:
          - sig: "fn new() -> Self"
            desc: Create empty sparse vector
          - sig: "fn random() -> Self"
            desc: Generate random sparse vector with ~1% density
          - sig: "fn encode_data(data: &[u8], config: &ReversibleVSAConfig, path: Option<&str>) -> Self"
            desc: Reversible data encoding (used by EmbrFS)
          - sig: "fn decode_data(&self, config: &ReversibleVSAConfig, path: Option<&str>, expected_size: usize) -> Vec<u8>"
            desc: Approximate decode (CorrectionStore provides bit-perfect recovery)
          - sig: "fn from_data(data: &[u8]) -> Self"
            desc: Deterministic vector from SHA256 seed
          - sig: "fn bundle(&self, other: &SparseVec) -> SparseVec"
            desc: Associative superposition (⊕)
          - sig: "fn bind(&self, other: &SparseVec) -> SparseVec"
            desc: Non-commutative composition (⊙)
          - sig: "fn cosine(&self, other: &SparseVec) -> f64"
            desc: Cosine similarity [-1, 1]
        derives: [Clone, Debug, Serialize, Deserialize, Default]
        
    to_add:
      - name: VSAConfig
        type: struct
        fields:
          - {name: dimensionality, type: usize}
          - {name: target_non_zero, type: usize}
          - {name: sparsity, type: f32}
        methods:
          - sig: "fn new(dimensionality: usize) -> Self"
          - sig: "fn high_precision() -> Self"
            desc: "100K dims, 0.2% sparsity"
          - sig: "fn balanced() -> Self"
            desc: "50K dims, 0.4% sparsity"
          - sig: "fn fast() -> Self"
            desc: "10K dims, 2% sparsity"
            
      - name: permute
        type: method
        sig: "fn permute(&self, shift: usize) -> SparseVec"
        desc: Cyclic shift for order encoding
        
      - name: inverse_permute
        type: method
        sig: "fn inverse_permute(&self, shift: usize) -> SparseVec"
        desc: Reverse cyclic shift
        
      - name: thin
        type: method
        sig: "fn thin(&self, target_density: f32) -> SparseVec"
        desc: Context-dependent thinning

  embrfs:
    path: src/embrfs.rs
    exports:
      - name: EmbrFS
        type: struct
        desc: Holographic filesystem
        
      - name: Engram
        type: struct
        fields:
          - {name: root, type: SparseVec}
          - {name: codebook, type: "HashMap<usize, SparseVec>"}
          - {name: corrections, type: CorrectionStore}
        methods:
          - sig: "fn query_codebook(&self, query: &SparseVec, k: usize) -> Vec<RerankedResult>"
            desc: "Index codebook, generate candidates, rerank by cosine"
          
    to_add:
      - name: HierarchicalManifest
        type: struct
        fields:
          - {name: version, type: u32}
          - {name: levels, type: "Vec<ManifestLevel>"}
          - {name: sub_engrams, type: "HashMap<String, SubEngram>"}
          
      - name: SubEngram
        type: struct
        fields:
          - {name: id, type: String}
          - {name: root, type: SparseVec}
          - {name: chunk_count, type: usize}
          - {name: children, type: "Vec<String>"}

  resonator:
    path: src/resonator.rs
    exports:
      - name: Resonator
        type: struct
        fields:
          - {name: codebook, type: "Vec<SparseVec>"}
          - {name: max_iterations, type: usize, default: 10}
          - {name: convergence_threshold, type: f64, default: 0.001}
        methods:
          - sig: "fn new() -> Self"
          - sig: "fn factorize(&self, compound: &SparseVec, num_factors: usize) -> FactorizeResult"
            desc: Iteratively factor compound vector
          - sig: "fn project(&self, noisy: &SparseVec) -> SparseVec"
            desc: Project onto codebook subspace

  retrieval:
    path: src/retrieval.rs
    exports:
      - name: SearchResult
        type: struct
        fields:
          - {name: id, type: usize}
          - {name: score, type: i32}
      - name: RerankedResult
        type: struct
        fields:
          - {name: id, type: usize}
          - {name: approx_score, type: i32}
          - {name: cosine, type: f64}
      - name: TernaryInvertedIndex
        type: struct
        desc: "Inverted index for sparse ternary vectors (candidate generation for semantic search)"
        methods:
          - sig: "fn new() -> Self"
          - sig: "fn add(&mut self, id: usize, vec: &SparseVec)"
          - sig: "fn finalize(&mut self)"
          - sig: "fn build_from_map(map: &HashMap<usize, SparseVec>) -> Self"
          - sig: "fn query_top_k(&self, query: &SparseVec, k: usize) -> Vec<SearchResult>"
          - sig: "fn query_top_k_reranked(&self, query: &SparseVec, vectors: &HashMap<usize, SparseVec>, candidate_k: usize, k: usize) -> Vec<RerankedResult>"
      - name: rerank_candidates_by_cosine
        type: fn
        sig: "fn rerank_candidates_by_cosine(query: &SparseVec, candidates: &[SearchResult], vectors: &HashMap<usize, SparseVec>, k: usize) -> Vec<RerankedResult>"

  ternary_vec:
    path: src/ternary_vec.rs
    exports:
      - name: PackedTritVec
        type: struct
        desc: "Packed ternary vector (2 bits per dimension) for ternary-native fast paths"
        methods:
          - sig: "fn new_zero(len: usize) -> Self"
          - sig: "fn from_sparsevec(vec: &SparseVec, len: usize) -> Self"
          - sig: "fn to_sparsevec(&self) -> SparseVec"
          - sig: "fn dot(&self, other: &Self) -> i32"
          - sig: "fn bind(&self, other: &Self) -> Self"
          - sig: "fn bundle(&self, other: &Self) -> Self"

  kernel_interop:
    path: src/kernel_interop.rs
    exports:
      - name: VsaBackend
        type: trait
        desc: "Minimal backend-agnostic VSA operations for kernel/runtime interop"
      - name: SparseVecBackend
        type: struct
        desc: "Default VSA backend implementation using SparseVec"
      - name: VectorStore
        type: trait
      - name: CandidateGenerator
        type: trait
      - name: rerank_top_k_by_cosine
        type: fn
        desc: "Rerank candidate IDs using backend cosine + store lookup"

  fuse:
    path: src/fuse.rs
    status: TO_CREATE
    crate_dep: fuser
    exports:
      - name: EmbrFuse
        type: struct
        implements: fuser::Filesystem
        methods:
          - sig: "fn lookup(&mut self, req: &Request, parent: u64, name: &OsStr, reply: ReplyEntry)"
          - sig: "fn read(&mut self, req: &Request, ino: u64, fh: u64, offset: i64, size: u32, flags: i32, lock_owner: Option<u64>, reply: ReplyData)"

cli:
  path: src/cli.rs
  commands:
    existing:
      - {name: ingest, desc: "Encode directory to engram"}
      - {name: extract, desc: "Reconstruct from engram"}
      - {name: query, desc: "Search engram by similarity"}
    to_add:
      - {name: "ingest --hierarchical", desc: "Multi-level encoding for large datasets"}
      - {name: "mount", desc: "FUSE mount engram"}
      - {name: "config", desc: "Show/set VSA configuration"}

file_index:
  source:
    - {path: src/vsa.rs, lines: 278, desc: "VSA operations"}
    - {path: src/embrfs.rs, desc: "Filesystem encoding"}
    - {path: src/cli.rs, desc: "CLI interface"}
    - {path: src/lib.rs, desc: "Library exports"}
    - {path: src/main.rs, desc: "Entry point"}
  tests:
    - {path: tests/unit_tests.rs, count: 11}
    - {path: tests/integration_cli.rs, count: 7}
    - {path: tests/e2e_regression.rs, count: 6}
    - {path: tests/ternary_refactor_invariants.rs, desc: "Reference invariants for ternary refactors (feature: ternary-refactor)"}
  benches:
    - {path: benches/vsa_ops.rs, desc: "Criterion benches for SparseVec ops + reversible encode/decode"}
    - {path: benches/retrieval.rs, desc: "Criterion benches for inverted index build/query"}
  docs:
    - {path: docs/adr/, count: 7}
    - {path: context.md, desc: "Research context"}
    - {path: context-1.md, desc: "Engineering plan"}
    - {path: docs/THROUGHPUT.md, desc: "Throughput-focused change log and profiling anchors"}
    - {path: docs/RETRIEVAL_INDEX.md, desc: "Inverted index plan + current implementation"}
    - {path: docs/RECURSIVE_UNFOLDING.md, desc: "Selective hierarchical retrieval + differential updates design"}
    - {path: docs/BALANCED_TERNARY_REFACTOR_ROADMAP.md, desc: "Plan to make balanced ternary the default substrate"}
    - {path: TASK_REGISTRY.md, desc: "Task tracking"}
